# Algorithm
CodeSpace로 Algorithm을 공부하고자 기존 레포를 변경했습니다.

## 다시 풀어야할 문제
> 1874(221208), 1966(221210)

## 복기할 사항

### ~221018
> 10951
> - 끝내는 조건이 없는 경우 -> try except 사용

### 221029
> 7568
> - 그냥 자신보다 큰 rank인 사람이 몇명인지만 파악하면 되는 문제
> 1920
> - 이진탐색 관련문제, end = mid-1, start = mid+1 식으로 바뀌어야 한다는것

### 221208
> 11651
> - 2개의 기준으로 리스트를 정렬하는 방법
> > sorted(listName, key= lambda l:(l[0], l[1]))
> > (l[0], l[1]) 부분이 핵심 
> 1874
> - 무식하게 리스트를 때려넣으면 안될거같지만 기껏해봐야 10만개이기 때문에 가능하긴 하더라...
> - "수열이 이전 숫자보다 크면 그 숫자까지 입력하고 pop, 이전 숫자보다 작으면 지금까지 push된 리스트의 가장 마지막 숫자가 수열에서 원하는 숫자인지 확인. 만약 아니라면 잘못된 수열." 이라는 규칙을 찾아내면 풀 수 있는 문제이다.

### 221210
> 2805
> - 이진탐색으로 벌목 가능한 최대 높이 찾는 방법
> > 마지막에 print(end)를 하면 가능한 최대높이를 구할 수 있음
> - python3 으로하면 시간초과가 나오니 Pypy3으로 하자
> - 이진탐색은 end-1, start+1로 점점 좁혀나가는거라고 기억하자
> 1966
> - 시간복잡도를 잘 계산해야한다. 최대로 계산했을 때 어느 방향이 가장 쉽고 단순하게 구현할 수 있을지...
> - List의 pop과 del의 시간복잡도는 (n)으로 같기 때문에 무엇을 사용해도 상관은 없다.
> - 조건을 잘 분석하고 분기를 잘 만들어야한다. 생각만으로 풀기에는 한없이 복잡해져가는 풀이가 만들어질 수 있다. 주의!
> 10816
> > print(' '.join(map(str, result))) 부분 확인하기
> 리스트를 공백 없이 출력하는 방법이니 숙지하고 있자