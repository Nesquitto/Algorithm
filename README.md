# Algorithm
CodeSpace로 Algorithm을 공부하고자 기존 레포를 변경했습니다.

## 다시 풀어야할 문제
> 1874(221208), 1966(221210), 1654(221211)

## 복기할 사항

### ~221018
> 10951
> - 끝내는 조건이 없는 경우 -> try except 사용

### 221029
> 7568
> - 그냥 자신보다 큰 rank인 사람이 몇명인지만 파악하면 되는 문제
> 1920
> - 이진탐색 관련문제, end = mid-1, start = mid+1 식으로 바뀌어야 한다는것

### 221208
> 11651
> - 2개의 기준으로 리스트를 정렬하는 방법
> > sorted(listName, key= lambda l:(l[0], l[1]))
> > (l[0], l[1]) 부분이 핵심 
> 1874
> - 무식하게 리스트를 때려넣으면 안될거같지만 기껏해봐야 10만개이기 때문에 가능하긴 하더라...
> - "수열이 이전 숫자보다 크면 그 숫자까지 입력하고 pop, 이전 숫자보다 작으면 지금까지 push된 리스트의 가장 마지막 숫자가 수열에서 원하는 숫자인지 확인. 만약 아니라면 잘못된 수열." 이라는 규칙을 찾아내면 풀 수 있는 문제이다.

### 221210
> 2805
> - 이진탐색으로 벌목 가능한 최대 높이 찾는 방법
> > 마지막에 print(end)를 하면 가능한 최대높이를 구할 수 있음
> - python3 으로하면 시간초과가 나오니 Pypy3으로 하자
> - 이진탐색은 end-1, start+1로 점점 좁혀나가는거라고 기억하자
> 1966
> - 시간복잡도를 잘 계산해야한다. 최대로 계산했을 때 어느 방향이 가장 쉽고 단순하게 구현할 수 있을지...
> - List의 pop과 del의 시간복잡도는 (n)으로 같기 때문에 무엇을 사용해도 상관은 없다.
> - 조건을 잘 분석하고 분기를 잘 만들어야한다. 생각만으로 풀기에는 한없이 복잡해져가는 풀이가 만들어질 수 있다. 주의!
> 10816
> > print(' '.join(map(str, result))) 부분 확인하기
> 리스트를 공백 없이 출력하는 방법이니 숙지하고 있자

### 221211
> 1654
> - 문제 조건으로 인해 나누는 값에 mid가 들어갈 수 있는데 mid가 0이면 zero division error가 뜬다. 해당 요소를 예외처리 해주어야한다.
> - 이진탐색은 항상 계속 풀어줘야할것 같다. 생각보다 신경써야할 부분이 너무 많다.
> 2108
> round(n): n의 자리에서 반올림한다. default = 0
> Counter: collection에 포함되어있다. 리스트의 값들을 각각의 값들이 몇 번 나왔는지 확인할 수 있다. most_common과 같은 많이 존재한 값들 순으로 정렬하는 함수도 존재한다.
> 시간복잡도가 python3으로 하면 어렵다. pypy3으로 하자

### 221213
> 1764
> - 문제가 두 가지 조건을 모두 만족하는 사람을 출력하는 것이기 때문에, set의 intersection이라는 교집합 함수를 이용하면 편할 것 같았다. 시간초과도 이게 제일 안전할거같았고... 집합을 사용했다는 것을 기억하자

### 230124
> 11047
> - 탐욕 알고리즘 문제이다. 앞의 선택이 이후의 선택에 영향을 주지 않는다는 것이며, 최적 부분 구조 조건은 문제에 대한 최적해가 부분문제에 대해서도 역시 최적해라는 것이다.
> - 그리디에 해당하는 종류의 문제는 많지 않으니 기억해두자.

### 230126
> 2579
> - dp 문제다. 어느정도 감이 남아있기는 한데... 런타임 에러를 많이 만들었다! 값을 경계값을 넣을 때 직접 실행을 해보도록 하자! 흐아아ㅏ아
> 11723
> - set 구현하는 문제이지만, 이미 set이 구현되어있기 때문에 해당 함수를 이용하여 문제를 풀었다. 주의해야할 점은 set의 remove는 삭제하려는 값이 있어야지만 삭제가 되고, 없다면 keyError를 반환한다는 것이다. 이 KeyError를 딕셔너리의 Key로 헷갈려서 삽질할 수도 있으니 해당 remove 함수는 기억하고 있자.